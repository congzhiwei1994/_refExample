#pragma kernel ComputeFFT SIZE=32 PASSES=5 CHANNEL=x TX=32 TY=1 FINAL=0//0
#pragma kernel ComputeFFT SIZE=32 PASSES=5 CHANNEL=y TX=1 TY=32 FINAL=1//1
#pragma kernel ComputeFFT SIZE=64 PASSES=6 CHANNEL=x TX=64 TY=1 FINAL=0//2
#pragma kernel ComputeFFT SIZE=64 PASSES=6 CHANNEL=y TX=1 TY=64 FINAL=1//3
#pragma kernel ComputeFFT SIZE=128 PASSES=7 CHANNEL=x TX=128 TY=1 FINAL=0//4
#pragma kernel ComputeFFT SIZE=128 PASSES=7 CHANNEL=y TX=1 TY=128 FINAL=1//5
#pragma kernel ComputeFFT SIZE=256 PASSES=8 CHANNEL=x TX=256 TY=1 FINAL=0//6
#pragma kernel ComputeFFT SIZE=256 PASSES=8 CHANNEL=y TX=1 TY=256 FINAL=1//7
#pragma kernel ComputeFFT SIZE=512 PASSES=9 CHANNEL=x TX=512 TY=1 FINAL=0//8
#pragma kernel ComputeFFT SIZE=512 PASSES=9 CHANNEL=y TX=1 TY=512 FINAL=1//9



Texture2D<float2> inputH;
Texture2D<float2> inputX;
Texture2D<float2> inputZ;
Texture2D<float2> inputButterfly;
#if !FINAL
RWTexture2D<float2> output1;
RWTexture2D<float2> output2;
RWTexture2D<float2> output3;
#else
RWTexture2D<float3> output;
#endif

groupshared float2 intermediatesH[SIZE];
groupshared float2 scratchH[SIZE];
groupshared float2 intermediatesX[SIZE];
groupshared float2 scratchX[SIZE];
groupshared float2 intermediatesZ[SIZE];
groupshared float2 scratchZ[SIZE];


uint crossReversebits( uint x )
{
	x = ((x >> 1) & 0x55555555u) | ((x & 0x55555555u) << 1);
	x = ((x >> 2) & 0x33333333u) | ((x & 0x33333333u) << 2);
	x = ((x >> 4) & 0x0f0f0f0fu) | ((x & 0x0f0f0f0fu) << 4);
	x = ((x >> 8) & 0x00ff00ffu) | ((x & 0x00ff00ffu) << 8);
	x = ((x >> 16) & 0xffffu) | ((x & 0xffffu) << 16);
	return x;
}

void ButterflyPass(float2 butterfly, uint coord, uint passIndex)
{
	uint indexA, indexB;

	uint offset = 1 << passIndex;
	if ((coord / offset) % 2 == 1)
	{
		indexA = coord - offset;
		indexB = coord;
	}
	else
	{
		indexA = coord;
		indexB = coord + offset;
	}

	if (passIndex == 0)
	{
		indexA = crossReversebits(indexA) >> (32 - PASSES);
		indexB = crossReversebits(indexB) >> (32 - PASSES);
	}

	const bool pingpong = (passIndex % 2) == 0;

	float2 valueA_H, valueB_H;
	float2 valueA_X, valueB_X;
	float2 valueA_Z, valueB_Z;
	if (pingpong)
	{
		valueA_H = intermediatesH[indexA];
		valueB_H = intermediatesH[indexB];

		valueA_X = intermediatesX[indexA];
		valueB_X = intermediatesX[indexB];

		valueA_Z = intermediatesZ[indexA];
		valueB_Z = intermediatesZ[indexB];
	}
	else
	{
		valueA_H = scratchH[indexA];
		valueB_H = scratchH[indexB];

		valueA_X = scratchX[indexA];
		valueB_X = scratchX[indexB];

		valueA_Z = scratchZ[indexA];
		valueB_Z = scratchZ[indexB];
	}

	float2 weight = butterfly.xy;
	float2 weightedValueH = weight * valueB_H.r + weight.gr * valueB_H.g * float2(-1, 1);
	float2 weightedValueX = weight * valueB_X.r + weight.gr * valueB_X.g * float2(-1, 1);
	float2 weightedValueZ = weight * valueB_Z.r + weight.gr * valueB_Z.g * float2(-1, 1);
	float2 resultH = valueA_H + weightedValueH;
	float2 resultX = valueA_X + weightedValueX;
	float2 resultZ = valueA_Z + weightedValueZ;

	if (pingpong)
	{
		scratchH[coord] = resultH;
		scratchX[coord] = resultX;
		scratchZ[coord] = resultZ;
	}
	else
	{
		intermediatesH[coord] = resultH;
		intermediatesX[coord] = resultX;
		intermediatesZ[coord] = resultZ;
	}
}

float2 conj(float2 v)
{
	return float2(v.x, -v.y);
}

[numthreads(TX,TY,1)]
void ComputeFFT(uint2 id : SV_DispatchThreadID)
{
	uint coord = id.CHANNEL;
#if !FINAL
	intermediatesH[coord] = conj(inputH[uint2(id.x, id.y)]);
	intermediatesX[coord] = conj(inputX[uint2(id.x, id.y)]);
	intermediatesZ[coord] = conj(inputZ[uint2(id.x, id.y)]);
#else
	intermediatesH[coord] = inputH[id];
	intermediatesX[coord] = inputX[id];
	intermediatesZ[coord] = inputZ[id];
#endif

	[unroll(PASSES)]
	for (uint passIndex = 0; passIndex < PASSES; ++passIndex)
	{
		GroupMemoryBarrierWithGroupSync();
		ButterflyPass(inputButterfly[uint2(coord, passIndex)].xy, coord, passIndex);
	}

	GroupMemoryBarrierWithGroupSync();

	const bool pingpong = (PASSES % 2) == 0;
	const float2 resultH = pingpong ? intermediatesH[coord] : scratchH[coord];
	const float2 resultX = pingpong ? intermediatesX[coord] : scratchX[coord];
	const float2 resultZ = pingpong ? intermediatesZ[coord] : scratchZ[coord];
#if !FINAL
	output1[id] = resultH;
	output2[id] = resultX;
	output3[id] = resultZ;
#else
	const float sign = ((id.x + id.y) % 2) == 1 ? -1.0f : 1.0f;
	float3 res = float3(sign * resultX.x, sign * resultH.x, sign * resultZ.x);
	output[id] = float3(sign * resultX.x, sign * resultH.x, sign * resultZ.x);
	
#endif
}
